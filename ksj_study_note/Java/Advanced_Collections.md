# 자바 컬렉션 프레임워크 고급

---

## 🔹 컬렉션의 설계 철학

Java의 컬렉션 프레임워크는 "인터페이스 기반 설계"를 기반으로 한다.  
즉, 실제 구현체에 직접 의존하지 않고, 공통된 행위에 따라 `List`, `Set`, `Map` 등의 인터페이스를 정의한 후, 다양한 상황에 맞는 구현체(ArrayList, HashSet, TreeMap 등)를 선택적으로 사용하도록 설계되어 있다.

이 방식은 다음과 같은 이점을 제공한다:
- 코드 유연성: 구현체를 바꿔도 상위 코드 영향 없음
- 일관성 유지: 모든 컬렉션은 공통된 메서드 시그니처와 계약(contract)을 따른다
- 알고리즘 대체 가능: 요구사항에 따라 시간복잡도 기준으로 구현체를 유연하게 변경 가능

---

## 🔹 주요 컬렉션 인터페이스 비교

| 인터페이스 | 특징                         | 주요 구현체         |
|------------|------------------------------|---------------------|
| List       | 순서 유지, 중복 허용          | ArrayList, LinkedList |
| Set        | 순서 없음, 중복 불가          | HashSet, TreeSet    |
| Map        | 키-값 쌍 저장, 키 중복 불가    | HashMap, TreeMap    |

각 인터페이스는 `Collection` 또는 `Map`이라는 상위 루트를 갖고 있으며,  
구현체는 성능, 정렬, 동기화 여부에 따라 특화되어 있다.

---

## 🔹 구현체 성능 및 용도 비교

### List 계열
- `ArrayList`: 배열 기반, **탐색 속도 빠름**, 삽입/삭제 느림
- `LinkedList`: 노드 기반, **삽입/삭제 빠름**, 인덱스 접근 느림

### Set 계열
- `HashSet`: 해시 기반, 중복 제거, 순서 보장 없음
- `LinkedHashSet`: 입력 순서 유지
- `TreeSet`: 이진 트리 기반 정렬 저장, 탐색 범위 기반 처리 가능

### Map 계열
- `HashMap`: 해시 기반, null key 1개 허용
- `LinkedHashMap`: 순서 유지 + 해시
- `TreeMap`: 키 정렬 유지 (이진 탐색 트리 기반)

---

## 🔹 Iterable, Iterator, ListIterator 차이

- `Iterable`: `for-each` 문을 가능하게 해주는 최소 인터페이스 (`iterator()` 제공)
- `Iterator`: 순방향 탐색 및 안전한 제거 (`remove()` 제공)
- `ListIterator`: 양방향 순회 가능 (`previous()`, `add()` 등 포함)

이 차이를 이해하고 컬렉션을 순회할 때 어떤 타입의 반복자가 필요한지 판단할 수 있어야 한다.

---

## 🔹 equals()와 hashCode() 계약

Set과 Map 계열에서는 객체 비교에 `equals()`와 `hashCode()` 메서드를 사용하므로,  
커스텀 객체를 키나 요소로 사용할 경우 반드시 다음을 보장해야 한다:

1. `a.equals(b) == true` 이면 `a.hashCode() == b.hashCode()` 도 반드시 true
2. `hashCode()`는 가능한 고르게 분산되도록 구현
3. 불변 필드 기반으로 작성할 것 (mutable 필드 기반일 경우 자료구조가 깨질 수 있음)

---

## 🔹 동기화와 병렬 처리

컬렉션은 기본적으로 **비동기 구조**이며, 멀티스레드 환경에서 다음과 같은 방법으로 처리한다:

- `Collections.synchronizedList()` 등으로 래핑
- `ConcurrentHashMap`, `CopyOnWriteArrayList` 등 병행 처리 전용 클래스 사용
- Java 8 이후: `parallelStream()` 으로 병렬 스트림 처리

---

## 🔹 성능 튜닝 시 고려할 점

- 초기 용량 설정 (`ArrayList`, `HashMap` 등은 초기 크기를 잘못 설정하면 resizing cost 발생)
- null 허용 여부 (TreeMap은 null 키 허용 X)
- Iterator 대신 Stream API 사용 시 병렬성, 지연 실행 고려
- 객체 해시 충돌이 많은 경우 Hash 기반 구조 성능 저하 발생

---

## ✅ 정리 요약

- 컬렉션 프레임워크는 인터페이스 기반 설계를 통해 다양한 요구를 충족시킬 수 있는 유연한 구조를 제공한다.
- 구현체 선택은 자료 구조 특성, 탐색/삽입/삭제 속도, 메모리 구조에 따라 신중히 이루어져야 한다.
- 커스텀 객체를 사용할 경우 equals/hashCode 계약을 반드시 준수해야 하며, 멀티스레드 환경에서는 적절한 동기화 구조를 사용해야 한다.
