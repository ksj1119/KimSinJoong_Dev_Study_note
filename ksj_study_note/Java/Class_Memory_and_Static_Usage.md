# 클래스 메모리 구조와 static vs instance의 차이

---

## 🔹 클래스와 객체의 메모리 배치

Java에서 클래스는 JVM의 Method Area(또는 Metaspace)에 로딩되며, 해당 클래스에서 생성되는 객체는 Heap 영역에 저장된다.

- **클래스 정보 (메서드, static 변수 등)**: 클래스가 JVM에 로딩될 때 Method Area에 할당
- **인스턴스 필드**: 객체가 생성될 때마다 별도의 Heap 메모리에 생성
- **지역 변수**: 메서드 호출 시 Stack 프레임에 저장

이러한 구조는 클래스가 몇 번 인스턴스화되든 static 필드는 오직 하나만 존재하게 만들며, 인스턴스 필드는 각 객체마다 따로 존재하게 한다.

---

## 🔹 static의 의미와 목적

- **공유 자원**: 클래스 수준에서 공유되는 자원
- **정적 초기화**: 프로그램 시작 시점에 초기화 가능
- **유틸리티 용도**: 인스턴스 생성 없이 사용 가능한 기능 구현

예를 들어, `Math` 클래스의 `Math.abs()` 같은 정적 메서드는 별도의 객체 없이 호출 가능하다. 이는 유틸리티 성격의 기능에 적합하다.

---

## 🔹 instance의 의미와 목적

- **객체 고유의 상태 유지**: 필드가 객체에 종속됨
- **캡슐화 및 다형성 기반 설계**: 개별 객체의 상태를 기반으로 동작
- **OOP 설계 기본 단위**: 생성자 호출을 통한 상태 생성 및 초기화

instance 필드는 객체의 식별성과 행위를 유지하는 데 필수적인 요소이며, 대부분의 실제 비즈니스 로직은 instance 수준에서 구현된다.

---

## 🔹 static 필드의 위험성

- **상태 공유로 인한 사이드 이펙트**: 여러 객체가 동일한 필드에 접근하면서 의도치 않은 결과 발생 가능
- **GC 대상 제외**: 클래스가 언로드되지 않는 이상 static 필드는 JVM 종료 전까지 살아있음
- **테스트 어려움**: static 필드는 상태 초기화나 mocking이 어려워 테스트 코드 작성에 불리함

---

## 🔹 메모리 구조 요약

| 영역           | 설명                                   |
|----------------|----------------------------------------|
| Method Area    | 클래스 로딩 정보, static 변수, 상수    |
| Heap           | 인스턴스 변수, 객체 본체               |
| Stack          | 지역 변수, 메서드 호출 스택 프레임     |

---

## ✅ 정리 요약

- static은 클래스 단위로 관리되며 메모리를 공유하고, instance는 객체별 독립 상태를 유지한다.
- 클래스가 메모리에 로딩되면 static 필드가 Method Area에 고정되며, 객체를 생성하면 instance 필드가 Heap에 동적으로 생성된다.
- static은 효율성과 공유를 위한 도구이지만, 남용 시 설계 유연성을 해치고 테스트 가능성을 저하시킬 수 있다.
