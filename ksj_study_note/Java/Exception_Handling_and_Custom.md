# 예외 처리와 사용자 정의 예외 설계

---

## 🔹 예외(Exception)란?

예외는 프로그램 실행 중 발생할 수 있는 **비정상적 상황**을 의미하며, Java에서는 `Throwable` 클래스를 루트로 하는 계층 구조로 관리합니다.  
예외는 프로그램 흐름을 안전하게 제어하기 위한 핵심 수단입니다.

---

## 🔹 Java의 예외 계층 설명

Java의 예외는 최상위 클래스인 `Throwable`을 기준으로 두 갈래로 나뉩니다:

- `Error` 클래스: JVM 수준의 치명적인 오류 (예: `OutOfMemoryError`, `StackOverflowError`)  
  → 복구 불가능, catch 불필요
- `Exception` 클래스: 애플리케이션 수준의 예외 처리 대상

  - **Checked Exception**: `IOException`, `SQLException` 등  
    → 컴파일러가 처리 강제. 반드시 `throws` 또는 `try-catch` 필요
  - **Unchecked Exception**: `NullPointerException`, `IllegalArgumentException` 등  
    → 컴파일러가 강제하지 않음. 주로 논리 오류나 개발자 실수

---

## 🔹 예외 처리 방식

### 1. try-catch-finally  
- 특정 블록 내에서 예외 발생 가능성이 있는 코드를 감싸 처리  
- `finally`는 예외 발생 여부와 상관없이 무조건 실행됨

### 2. throws 선언  
- 메서드 시그니처에 예외 발생 가능성을 명시하고 호출자에게 위임

---

## 🔹 사용자 정의 예외 설계

비즈니스 로직에 맞는 의미 있는 예외를 직접 정의하면, 시스템의 오류 원인을 명확히 전달하고 분기 처리를 깔끔하게 할 수 있습니다.

### 설계 시 고려할 요소

- `Exception` 혹은 `RuntimeException` 중 어떤 것을 상속할지 결정  
  → Checked는 API 신뢰도 확보, Unchecked는 간결성 확보
- 생성자 오버로딩: 메시지, 원인(cause) 전달 가능하게 구성
- `errorCode`, `logLevel` 등의 커스텀 필드 포함 가능

---

## 🔹 예외 설계 Best Practices

- 도메인 또는 계층별로 예외 클래스를 분리하여 유지보수성 향상
- 예외 wrapping을 통해 낮은 수준의 예외를 의미 있는 형태로 감싸기
- 로그 기록 시 일관된 메시지 형식 유지
- catch 블록에서 `Exception` 전체를 catch하지 말고 구체적으로 명시

---

## 🔹 예외 처리 전략

| 전략       | 목적                              | 사용 예시                     |
|------------|-----------------------------------|-------------------------------|
| Fail Fast  | 오류 즉시 감지 및 종료            | 유효성 검사, 널 체크 등       |
| Fail Safe  | 오류 발생해도 시스템 정상 작동 유지 | 외부 API 호출 실패 등         |
| Fallback   | 예외 발생 시 대체 로직 수행        | 타임아웃 시 캐시 조회 등       |

---

## ✅ 정리 요약

- Java는 Checked / Unchecked 예외를 구분하여 예외 처리 강제 여부를 설계에 반영합니다.
- 사용자 정의 예외는 도메인 중심의 의미 있는 설계를 가능하게 합니다.
- 예외는 단순히 에러를 잡는 것이 아니라, 전체 시스템 안정성과 설계 품질을 좌우하는 핵심입니다.
