# 📘 [1] JVM 구조와 Java 실행 과정

## 🔹 JVM(Java Virtual Machine) 이란?

JVM은 Java 애플리케이션을 OS에 독립적으로 실행시켜주는 가상 머신이다.  
Java로 작성된 `.java` 소스 파일은 컴파일러(javac)에 의해 `.class` 바이트코드로 변환되고,  
이 바이트코드는 JVM에 의해 해석되어 실행된다.

JVM은 다음과 같은 역할을 수행한다:

- **바이트코드 실행**: 클래스 로더를 통해 메모리에 적재된 바이트코드를 실행
- **메모리 관리**: 힙, 스택, 메서드 영역 등 메모리 구획을 관리
- **GC(Garbage Collection)**: 더 이상 사용되지 않는 객체를 자동으로 회수
- **스레드 관리**: 멀티스레딩 환경에서 스레드 스케줄링 및 동기화 지원
- **보안**: 클래스 검증기와 클래스 로딩 보안 메커니즘을 통해 보호된 실행 환경 제공

---

## 🔹 Java 실행 흐름

1. `.java` 파일 작성
2. `javac` 컴파일러로 `.class` 바이트코드 생성
3. JVM이 바이트코드를 로딩하여 실행

---

## 🔹 JVM 메모리 구조

| 영역 | 설명 |
|------|------|
| **Method Area** | 클래스, 메서드 메타정보 저장. static 변수 포함 |
| **Heap** | 인스턴스 및 배열 객체가 저장되는 영역. GC의 주요 대상 |
| **Stack** | 메서드 호출 시 생성되는 프레임 저장. 지역 변수, 매개변수 포함 |
| **PC Register** | 각 스레드가 실행 중인 명령어의 주소 저장 |
| **Native Method Stack** | C/C++ 기반 네이티브 코드 실행 시 사용 |

---

## 🔹 클래스 로딩 과정

클래스는 실행 시점에 동적으로 로딩된다. 순서는 다음과 같다:

1. **로딩(Loading)**: `.class` 파일을 찾아 메모리에 적재
2. **검증(Verification)**: 바이트코드의 안전성 검사
3. **준비(Preparation)**: static 변수 메모리 할당 및 기본값 설정
4. **해석(Resolution)**: 심볼릭 참조를 실제 참조로 변경
5. **초기화(Initialization)**: static 블록 및 static 변수 초기화

---

## 🔹 GC(Garbage Collection) 요약

- Java는 명시적인 `free()` 호출이 아닌, JVM이 **GC**를 통해 자동 메모리 관리
- **Young / Old / Metaspace**로 세대 분리
- GC 알고리즘: Serial, Parallel, CMS, G1 등 선택 가능 (JVM 옵션으로 튜닝)

---

## ✅ 요약

- JVM은 Java의 플랫폼 독립성을 보장하는 핵심 요소이며, 바이트코드 실행과 메모리 관리를 담당한다.
- 실행 과정은 `.java → .class → JVM → 실행` 순서로 흐른다.
- JVM은 여러 영역의 메모리를 체계적으로 관리하며, GC를 통해 자동으로 메모리를 정리한다.
- 클래스 로딩은 지연 로딩 방식으로, 런타임 시점에 필요한 클래스만 적재된다.
